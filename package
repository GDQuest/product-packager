#!/usr/bin/env sh
#
# Copyright (C) 2020 by Nathan Lovato and contributors
#
# This file is part of GDQuest product packager.
#
# GDQuest product packager is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software Foundation, either
# version 3 of the License, or (at your option) any later version.
#
# GDQuest product packager is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with GDQuest product
# packager. If not, see <https://www.gnu.org/licenses/>.

# Use semantic versioning with an optional hyphen-separated suffix, e.g. 0.3.2 or 1.0.0-dev
VERSION="0.1.0-dev"

# Debug
DRY_RUN=1
VERBOSITY=0
test $DRY_RUN -ne 0 && VERBOSITY=99

DIR_DIST=dist
DIR_CONTENT=content

# CONSTANTS
$VERBOSITY_INFO=1
$VERBOSITY_WARNING=2
$VERBOSITY_DEBUG=3

# UTILITY FUNCTIONS

# Prints a message only if the $VERBOSITY level is high enough
echo_debug() {
	test $VERBOSITY -ge $1 || exit

	case $1 in
	$VERBOSITY_INFO) prefix="INFO:" ;;
	$VERBOSITY_WARNING) prefix="WARNING:" ;;
	$VERBOSITY_DEBUG) prefix="DEBUG:" ;;
	*) exit ;;
	esac
	shift
	echo $prefix "$@"
}

find_chapter_directories() {
	find $DIR_CONTENT -maxdepth 1 -mindepth 1 -type d
}

# Finds output files in the $DIR_CONTENT directory and outputs it to the $DIR_DIST directory,
# replicating the chapters' structure.
# Warning: use locally, as the function uses 'eval' with 'find' to find files by extensions.
#
# Arguments:
# -- optional list of file extensions like "pdf html mp4" to filter the files to move.
move_output_files() {
	for path_chapter in find_chapter_directories; do
		dist_directory=$DIR_DIST/$(basename $path_chapter)

		find_patterns=$(test $@ && echo $@ | sed -E 's/(\w+)/-iname "*.\1" -o/g' | sed 's/\ -o$//')
		find_command=$(echo find $path_chapter -maxdepth 1 -mindepth 1)
		test $find_patterns && $find_command=$find_command$(echo " -type f \( $find_patterns \)")
		files=$(eval $find_command)
		files_string=$(printf "- %s\n" "${files}")

		echo_debug 1 "Found " $(echo $files_string | wc -l) " files to copy:\n" $files_string
		test $DRY_RUN -ne 0 && test -d $dist_directory || mkdir -p $dist_directory
		test $DRY_RUN -ne 0 && mv -v --backup --force $files $dist_directory
	done
}

render_videos_with_bpsrender() {
	bpsrender --help >/dev/null
	test $? -ne 0 && echo "There was an error running 'bpsrender'.
The program 'bpsrender' must be available on the system '\$PATH' variable for this program to work.
For more information, see https://en.wikipedia.org/wiki/PATH_(variable).
Cancelling video rendering." && exit 1

	blend_files=$(find $DIR_CONTENT -mindepth 1 -maxdepth 3 -type f -iname "*.blend")

	count=$(printf "%s\n" "${blend_files}" | wc -l)
	echo "\nRendering $count video projects with 'bpsrender'\n"

	content_path_length=$(echo $DIR_CONTENT | wc --chars)
	for blend_file in; do
		chapter_directory=$(echo $blend_file | cut --characters $content_path_length-)
		echo_debug 1 "Rendering file $blend_file"
		test $DRY_RUN -ne 0 && bpsrender --output $chapter_directory -- $blend_file
	done
}

# Arguments:
# $@: list of paths to video files
videos_compress_ffmpeg() {
	for path in $@; do
		directory=$(dirname $path)
		file=$(basename $path)
		name=$(echo $file | rev | cut -d. -f2- | rev)
		out_path=$directory/$name'-compressed.mp4'
		ffmpeg -i $path -c:a copy -c:v h264_nvenc -preset slow -qp 20 $out_path
		echo $out_path
	done

}

# Tries to reset git repositories to the master branch.
# Prints information about the process, and the list of repositories the function could not
# checkout.
#
# Arguments:
# $@ - a list of paths to git repositories. They can end up with the `.git` folder, the function
# will automatically normalize the paths.
#
# Flags:
# -s/--short - Only output the list of repositories that could not be checked out.
git_try_checkout_to_master() {

	start_dir=$(pwd)
	is_short_form=0
	case $1 in
	-s | --short)
		is_short_form=1
		shift
		;;
	esac

	# Filter and normalize git dirpaths
	git_directories=$(mktemp)
	for i in $@; do
		dir=$(echo $i | sed 's/\/\.git.*$//')
		cd $dir
		git status >/dev/null || continue
		echo $dir >>git_directories
	done

	file_errors=$(mktemp)
	for i in $(cat $git_directories); do
		cd $i

		status_output=$(git status --porcelain)

		test $is_short_form -eq 0 && test $(status_output) = "" || echo "The repository $i is dirty."

		output=$(git checkout master)
		test $is_short_form -eq 0 && echo $output
		if test $? -gt 0; then
			echo $i >>file_errors
		fi
	done

	test $is_short_form -eq 0 && echo \n"Couldn't checkout to master in the following repositories:"\n
	cat $file_errors
	cd $start_dir
}
main() {
	test $(echo $VERSION | cut -d- -f2) = "dev" && echo "Warning: this is a development version of the
program. It is not suitable for production use."

	test -d content || echo "Missing content/ directory, the program doesn't seem to be in a valid project, exiting." && exit 1
	exit 0
}

main
exit $?
